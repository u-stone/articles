      曾经在面试的时候有一个面试官问我这四个C++中常用的类型转换怎么用，我那时候好像说static_cast类似C里面的强制转换，const_cast用来去掉const性，dynamic_cast用来做继承体系里面类型的转换，reinterpret_cast用来重新解释内存数据。紧接着又问，static_cast和dynamic_cast有什么区别呢？我当时自己心里就感觉疑惑了，对啊，好像static_cast也可以替代dynamic_cast啊……好了我的故事就说到这里，如果你知道的跟我差不多那就看看这篇文章，如果知道的比我还少，那么，就看看这篇文章。高手请绕路了……
      我今天也是又碰到一些类似的问题，才翻开TCPL查阅一个究竟，然后若有所悟。
      首先应该提一下C++作为一种面向对象的强类型语言，在涉及到类型转换的时候应该考虑什么呢？按书中表，涉及到的有：对象的const、volatile性、访问控制规则和继承。所以在考察这四种类型转换的时候会分别提到这些内容。

static_cast
--------------------------------------------------------------------------------
      从C语言走过来的码农都会对下面的代码熟悉：
      float f = 3.14;
      int i = (int)f;
      这就是C里面的强制转换。在C++里面这种转换的近亲就应该是static_cast了。按TCPL中所述“static_cast运算符完成相关类型之间的转换，比如同一个类层次结构中一个指针类型到另一个指针类型的转换，整型到枚举型、或者浮点型的转换等“；所以我在回答面试官进一步的提问的时候不知道怎么回答了，因为static_cast也会参与dynamic_cast的一些事儿啊……这里先留个疑问。
      对于reinterpret_cast的使用，TCPL中说”reinterpret_cast处理互不相关的类型之间的转换，例如从整数到指针，或者从一个指针到另一个毫不相干的指针类型“，当然这并不是reinterpret_cast的全部论述，作为和static_cast的对比这里先论述这一部分。

const_cast
--------------------------------------------------------------------------------
      const_cast的设计很简单，就是为了在const成员中提供例外，比如说在const成员函数中修改成员变量：
      string Date::getDate()const{
          Date* th = const_cast<Date*>(this);
          th->changecache();
          return cache;
      }
      你可能会想，该函数加上这个const修饰，结果在实现中又要去掉，这是“不守承诺”。但是如果是用来提升性能的，那么就有用了：
      string Date::getDate()const{
          if (cachevalid == false){//需要的时候才重新计算cache
             Date* th = const_cast<Date*>(this);
             th->changecache();
             th->cachevalid = true;
          }
          return cache;
      }
      如果你认为干脆把getDate写成非const类型的，再使用cachevalid不是也可以吗？那么就要考虑下const提供了一个非const无法提供的承诺：一百年永不变！
      但是：
      Date *pd;
      const Date * pcd;
      pd->getDate();//OK，没问题
      pcd->getDate(); //这个就是未定义的了，还要看具体的编译器实现。
      好了，关于const_cast论述完毕。

reinterpret_cast
--------------------------------------------------------------------------------
      看这个名字你就应该猜个八九不离十，重新解释reinterpret。这个直接重新将给定的内存地址解释为某种类型。
      SomeKindOfType *obj = reinterpret_cast<SomeKindOfType *>(0x100000);
      像这样随便来一个地址，这家伙就可以给你重新解释该地址为一种类型的对象。真像是女娲造人一样，随便来一堆”泥巴“就可以造个”人“出来。TCPL中描述这种转换为最粗鲁的……没错，它就是这么不管不顾！
      所以，以后像这种要把某一个内存地址看做某种类型对象的事，第一个使用的就是这个reinterpret_cast莫属了。在此之后你可以再做其他转换，比如说static_cast，dynamic_cast。比如：
      static_cast<Base*>(reinterpret_cast<void*>(0xF0F0));

dynamic_cast
--------------------------------------------------------------------------------
      这个是四个cast中最麻烦的一个，也是用在继承结构中最得体的一个。其实，在实现上估计这也是最麻烦的一个，因为这个操作符要保存关于类型的信息，这样才可以认识对象的”真身“到底是谁，可以做哪些合法的转换；因为如果强转不成的话，是要告诉调用者转换不成功的（返回0）。同时又因为对象必须有关于多态的信息（虚表、虚指针），所以dynamic_cast只能操作指针类型和引用类型的对象，即dynamic_cast<T*>(pobj)和dynamic_cast<T&>(obj)。这里需要标记一下，这是和static_cast的一个区别。也就是说dynamic_cast对要求要进行转换的对象必须是多态的，说白了，就是必须有虚表、即必须有虚函数。但是dynamic_cast并没有限定目标类型必须是多态的。在使用这个操作符的时候可以这样考虑：对于dynamic_cast<T*>(pObj);就相当于问”pObj所指的对象是T*类型吗？“，当然有可能不是，你要做好准备分情况讨论。

      对指针类型和引用类型做dynamic_cast的时候，如果类型不相关，那么结果是不一样的。对于指针类型，如果转换失败会返回空指针；而对于引用类型，会抛出bad_cast异常。这是指针和引用类型的一个区别。

转换前后对象的变化
--------------------------------------------------------------------------------
      在这四种转换中转换前后的访问控制规则都是不变的。所以：
      class B : protected A{
          ....
      };
      void f(B * pB){
            B* pB1 = pB;
            A* pA =pB;// 错误，转换虽然存在但是，不能访问A中受保护成员
            A* pA2 = dynamic_cast<A*>(pB);//虽然可以通过编译，即编译期间正确，但是运行时转换失败返回0，即pA2为0
      }
      所以这里例子也引出了一个static_cast和dynamic_cast之间的区别：static_cast是编译期检查类型是否正确的，而dynamic_cast是运行期检查的。
      除了const_cast之外，其他的3个类型转换也不改变对象的const, volatile性质。

现在的回答
--------------------------------------------------------------------------------
      所以对于面试官的进一步提问，我的回答是，static_cast的类型判断属于编译期的，可以让编译器告诉你转换是否正确。而dynamic_cast主要是在运行期处理编译器无法确定的转换的，并且对要转换的对象也有要求：必须是指针类型或者是引用类型。